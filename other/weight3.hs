{- https://t.me/c/2129415057/6/334
Весы
Во столовой новые чашечные весы (вместимость каждой чашки 1 тонна) и гири массами 1г, 3г, 9г, 27г, и т.д.
по одной штуке каждой массы. Повар взял такие весы и не знает, можно ли взвесить что-нибудь тяжелое
и если можно, сколько гирь придется положить на весы (на любую чашку). Надо помочь ему.
Формат входных данных: единственное натуральное число – масса взвешиваемого товара в граммах (не больше 1000_000_000).
Формат выходных данных: единственное целое число – общее количество гирь
или число –1 если данный товар взвесить невозможно.

Examples
Input
8

Output
2
-}

solution :: Integer -> Int
solution w = let (n, (w', _)) = run 0 (w, 0)
             in if w' > 1000_000 then -1 else n

-- n - count of used weights
-- w1 - weight on the left pan of the scale
-- w2 - weight on the right pan of the scale
run :: Int -> (Integer, Integer) -> (Int, (Integer, Integer))
run n (w1, w2)
  | w1 == w2 = (n, (w1, w2)) -- return
  | w1 < w2 = run n (w2, w1) -- flip the scale
  | otherwise =
      let d = w1 - w2
          p = log3 (2 * d + 1) - 1
      in run (n + 1) (w1, w2 + 3^p)

log3 :: Integer -> Int
log3 0 = undefined
log3 1 = 0
log3 2 = 1
log3 n = 1 + log3 (n `divUp` 3)

log3Test :: Bool
log3Test = map log3 [1..100] == map (ceiling . logBase 3) [1..100]

divUp :: Integer -> Integer -> Integer
divUp x y = let (d, m) = divMod x y
            in d + (if m == 0 then 0 else 1)

{- explanation https://t.me/c/2129415057/6/356
Пусть груз лежит на левой чашке весов.
1. Рассмотрим систему счисления с "цифрами" -1, 0, 1 (кладём соответствующую гирю налево, никуда и направо соотв.)
Не сложно показать, что можно любое положительное число представить. 

Процесс такой:
Если начинаем с числа W, то надо брать старшую единицу при степени n = ceil(log3(2*W + 1)) - 1 (при гире весом n^3).
Это получается из того факта, что если старшая единица стоит при степени n,
то это покрывает интервал от S(n-1) + 1 до S(n), 
где S(n) = sum [3^i | i <- [0..n]]  - это сумма геометрической прогрессии и равна (3^(n-1) - 1)/2

2. Потом вычитаем из W эту гирю (W -= 3^n) получаем число от -S(n-1) до S(n-1).
Если результат положительный, то начинаем сначала, и старшая единица будет уже при гарантировано меньшей степени.
А если ушли в минус, то надо сменить везде знаки (перевернуть в уме весы) и мы снова уменьшили максимальную степень.

Из этого алгоритма прямо следует и доказательство, почему такое разложение всегда возможно
-}

solutionTest :: Bool
solutionTest = map (\x -> (x, solution x)) [0..20]
    == [(0,0),(1,1),(2,2),(3,1),(4,2),(5,3),(6,2),(7,3),(8,2),(9,1),(10,2),(11,3),(12,2),(13,3),(14,4),(15,3),
        (16,4),(17,3),(18,2),(19,3),(20,4)]
  && map solution [797150 .. 797162] == [12,11,12,13,12,13,12,11,12,13,12,13,-1]

test :: Bool
test = log3Test && solutionTest
